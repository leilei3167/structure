package main

/*
算法的定义:
算法是解决问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作
算法的特性:
输入
输出
有穷性
确定性
可行性
*/

/*
一.时间复杂度
时间复杂度概念:
语句总执行次数T(n)是关于问题规模n的函数,进而分析T(n)随n的变化情况并确定T(n)的数量级
记作:T(n)=O(f(n)),他表示随着问题规模的增大,算法执行时间增长率和f(n)的增长率相同,其中f(n)是问题
规模n的某个函数,使用O()来体现算法时间复杂度的方法,被称之为大O记法

一般来讲,随着n的增大,T(n)增长最慢的算法为最优算法

如何分析一个算法的时间复杂度?(即如何推导大O阶?)

方法:
	0.先获得运行次数函数f(n)的表达式
	1.对于运行次数函数,用常数1取代运行时间中所有的加法常数
	2.在修改后的运行次数函数中,只保留最高阶
	3.如果最高阶存在且不是1,则去除与这个项相乘的常数,最终结果就是大O阶(时间复杂度)

	大O其实就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度


*/
/*
常数阶:
	即O(1)复杂度,无论问题规模n的大小如何,执行时间都恒定,因为其执行次数不会随n变大而变多
线性阶:
	即O(n)复杂度,如循环累加,因为其执行次数和问题规模n挂钩
对数阶:
	即O(logn)复杂度,如:
	func log(n int) {
	a := 2
	for i := 0; i < n; i++ {
		a *= 2
	}
}
每一次相乘都会离n更近,2^x=n,即x=log2n
平方阶:
	O(n^2),如循环嵌套
对数阶会忽略底数的描述:以2为底n的对数 = 以2为底10的对数 乘以 以10为底n的对数,直接忽略常数项

常见时间复杂度排名:
	O(1)<O(logn)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<o(n!)<O(n^n)
必须避免n^2时间复杂度以上的算法!!

最坏情况与平均情况:
	最坏情况运行时间是一种保证,代表该算法最慢运行时间,如从n个随机数字中找到某个特定数字,最好情况是
	第一个数字就是(O(1)),最坏情况是全部浏览完毕最后一个才是(O(n)),分别被称之为最好时间复杂度
	和最坏时间复杂度,一般情况下都是指最坏时间复杂度
*/
/*
二.空间复杂度
在很多情况下,完全可以使用空间来换时间,如判断某个年份是否是闰年,可以选择构造某种算法,对于输入的值计算后
返回结果,另一种方法是将大量年份存到数组中,每次需要结果直接从数组中获取即可,但这种方式电脑需要提前存入
大量数据,时间,空间的取舍取决于实际的应用

一般情况下,讨论复杂度,都是指时间复杂度

*/
func main() {

}

func log(n int) {
	a := 1
	for i := 0; i < n; i++ {
		a *= 2
	}
}
