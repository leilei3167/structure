package main

import "fmt"

/*
二叉树
定义:
是n个节点的有限集合,该集合可以为空集,或者由一个根节点和两个互不相交的 分别称为根节点的左子树和右子树的二叉树组成

特点:
每个节点最多有2个孩子(最多2个子树),二叉树中不存在度大于2的节点
左子树和右子树是有顺序的,不能任意颠倒
即使树中某节点只有一颗子树,也要区分他是左还是右!

二叉树的五种形态:
1.空二叉树
2.只有一个根节点
3.根节点只有左子树
4.根节点只有右子树
5.根节点有左右子树

特殊的二叉树:
1.斜树
所有节点都只有左子树的叫左斜树,特点很明显,每一层都只有一个节点
2.满二叉树
所有节点都有左右子树,并且所有叶子都在同一层上;
叶子只能出现在最下一层,在其他层就不可能平衡;非叶子节点的度一定是2;同样深度的二叉树中,满二叉树的节点个数,叶子最多
3.完全二叉树
对具有n个节点的二叉树按层序编号,如果编号为i(1<=i<=n)的节点与同样深度的满二叉树中编号为i的节点在二叉树
中位置完全相同,则这个树为完全二叉树
按层序编号,指从左向右逐层编号
完全二叉树的特点:
	叶子一定在最下两层
	最下层的叶子一定集中在左边连续位置
	倒数第二层如果有叶子,一定是在右边连续位置
	如果节点度为1,则该节点只有左孩子
	同样节点数的二叉树,完全二叉树的深度最小

*/

/*
二叉树的性质:
1.在第i层最多右2的(i-1)次方个节点
2.深度为k的二叉树,最多总共有(2的k次方)减1个节点
3.任意一个二叉树,如果其终端节点数为n0,度为2的节点数为n2,则n0=n2+1  (终端节点数就是叶子节点数)
4.具有n个节点的完全二叉树的深度为不大于以2为底n的对数的最大整数+1,|log2n|+1,|x|表示不大于x的最大整数
5.对n个节点的完全二叉树按层编号,对任一节点i
	如果i=1,则该节点为根节点
	如果2i>n,则节点无左孩子,否则其左孩子是节点2i
	如果2i+1>n,则节点无右孩子,否则其右孩子是节点2i+1
*/

/* 顺序结构实现一般的数比较困难,但是对于二叉树这种特殊树来说,顺序结构也可以实现
一般来说顺序结构只适用于完全二叉树(因为普通二叉树序号不连续,空间造成浪费)

二叉树每个节点最多有2个孩子,所以可以设计一个数据与和两个指针域是比较自然得想法,这种就叫二叉链表
两个指针分别指向左孩子和右孩子
如果有需要,可以再增加一个指向其双亲得指针域
*/

/* 二叉树的遍历
指从根节点出发,按照某种次序依次访问二叉树中的所有节点,每个节点仅被访问一次
遍历方法主要有4种:

1.前序遍历
	先访问根节点,前序遍历左子树,再前序遍历右子树
2.中序遍历
	以根节点为开始(不是访问根节点),中序遍历左子树,然后访问根节点,再中序遍历右子树
3.后序遍历
	从左到右先叶子后节点的方式访问左右子树,然后访问根节点
4.层序遍历
	从第一层也就是根节点开始,从上到下逐层遍历,同一层中从左到右对节点进行访问

对于树的这种结构,对人来说很好理解,但是对于计算机来讲,他只有循环,判断等方式来处理,它只会处理线性的序列,
而以上的四种遍历方法,其实就是在把树中的节点变成某种意义的线性序列

*/

//https://zhuanlan.zhihu.com/p/136758152 二叉树

type TreeNode struct {
	Data       interface{}
	leftChild  *TreeNode
	rightChild *TreeNode
}

type BinaryTree struct {
	lenght int
	root   *TreeNode
}

//遍历方法都是用递归来进行实现
//前序遍历
func PreOrder(t *TreeNode) {
	if t == nil {
		return
	}
	fmt.Println(t.Data)    //先打印根节点值
	PreOrder(t.leftChild)  //先递归访问左子树
	PreOrder(t.rightChild) //然后递归访问右子树
}

func MidOrder(t *TreeNode) {
	if t == nil {
		return
	}
	MidOrder(t.leftChild)  //先递归访问左子树
	fmt.Println(t.Data)    //打印其节点值
	MidOrder(t.rightChild) //然后递归访问右子树
}

func PostOrder(t *TreeNode) {
	if t == nil {
		return
	}
	//从左到右先叶子后节点的方式访问左右子树
	PostOrder(t.leftChild)  //先递归访问左子树
	PostOrder(t.rightChild) //然后递归访问右子树
	fmt.Println(t.Data)     //打印其节点值
}

//前中后遍历的区别就是递归的顺序
//而层次遍历就比较复杂,需要使用一种广度遍历的方法,需要使用一个先进先出的队列

func main() {
	t := &TreeNode{Data: "A"}
	t.leftChild = &TreeNode{Data: "B"}
	t.rightChild = &TreeNode{Data: "C"}
	t.leftChild.leftChild = &TreeNode{Data: "D"}
	t.leftChild.rightChild = &TreeNode{Data: "E"}
	t.rightChild.leftChild = &TreeNode{Data: "F"}
	fmt.Println("前序遍历:")
	PreOrder(t)
	fmt.Println("中序遍历:")
	MidOrder(t)
	fmt.Println("后序遍历:")
	PostOrder(t)

}
