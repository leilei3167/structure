package main

/*
树是n个节点得有限集,n=0时为空树,
1.在任意一个非空得树中,有且仅有一个特定的成为根root得节点
2.当n>1时,其余节点可分为m个互不相交得有限集,每一个集合本身又是一棵树,称之为根得子树,子树之间
一定是不相交得


节点分类:
	节点拥有的子树数量成为度(degree),度为0的节点叫做叶节点,不为0的称为分支节点

	节点的子树的根称为该节点的child,该节点称为该孩子的双亲,同一个双亲的孩子节点间为兄弟,节点的祖先
	指从根节点开始到该节点所经分支上的所有节点

节点的层次从根开始定义,根为第一层,根的孩子为第二层,若某节点在第l层,其子树的根就在l+1层,双亲节点
在同一层的节点互为堂兄弟节点,节点的最大层次被称为深度或高度

如果树中节点的各子树从左至右是有序的,不能互换的,则称该树为有序树,否则是无序树

树的抽象数据类型:
操作与线性表完全不同:

ADT 树 tree
Data
	树是由一个根节点和若干子树构成,各节点之间存在层次关系
Operation
	构造树
	销毁树
	返回树的高度
	树是否为空
	返回树的根节点
	查找某个节点
	给某个节点赋值
	返回某个节点双亲
	返回某个节点最左孩子
	返回右兄弟
	插入孩子
	删除孩子

*/

/*
树的存储结构:
顺序结构无法只管的表示树的节点之间的逻辑关系,但是充分利用顺序和链式存储结构的特点,完全可以实现对树存储结构
的表示,三种表示方法:双亲表示法,孩子表示法,孩子兄弟表示法


一.双亲表示法:
	每一个节点一定有且仅有一个双亲(除了根节点),根节点的双亲为空,因此可以定义一个节点结构为,一个指针
	域指向双亲节点;
	由于根节点没有双亲,约定双亲位置为-1;这样的结构,使得找到任意一个节点的双亲变得非常容易,为O(1)
但是要找到孩子节点,只有遍历整个结构才能完成,为O(n),解决方法是在节点增加一个最左边孩子的指针域,这样就可以
很方便的得到节点的孩子

另一个场景是,非常关注兄弟之间的关系,双亲表示法无法体现,该怎么办?可以在每个节点添加一个右兄弟的指针域

存储结构的设计是非常灵活的,可以根据需要增删字段,便于运算,时间复杂度好不好等


*/
type Node struct {
	Data   interface{}
	parent int //这个节点的双亲
	//firstChild int //这个节点最左边的孩子,便于寻找其孩子,没有则设为-1

}

type tree struct {
	nodes  []Node //节点数组
	length int    //节点总数
	root   int    //根的位置
}

/* 二.孩子表示法
由于树中可能存在多个子树,可以考虑使用多重链表,即每个节点有多个指针域,其中每个指针指向一棵子树的根节点
这种方法就是多重链表表示法,但是,树的每个节点的度,也就是他的孩子个数是不同的,所以有两种方法来解决

1.指针域的个数就等于树的度(树的度是各个节点度的最大值)
这种方式在各个节点的度相差非常大时,显然是比较浪费空间的,因为很多指针域都是空的,但是当各阶段的度相差不大
时,那就意味着开辟的空间都充分利用了,既然很多指针域都会为空,那为什么不按需分配空间呢?于是就有了方法2

2.每个节点的指针域的个数等于该节点本身的度
需要在每个节点维护一个度(int表示度的值),每个节点的链表是不同的,所以在运算上会有时间上的损耗

如何构造一个空间利用率高,并且同时结构相同的树? 就是孩子表示法----
	把每个节点的孩子节点排列起来,以单链表作存储结构,则n个节点有n个孩子链表,如果是叶子节点则此单链表为空,
	然后n个头指针又组成一个线性表,采用顺序存储结构,放入数组中

为此,需要两种节点结构,一种是链表中,孩子链表的孩子节点,需要保存孩子节点的下标,以及其下一个孩子节点的指针(互为兄弟)
第二个是表头数组的表头节点,包含该节点的数据,以及其下一个孩子节点的指针

对于查找某个节点的某个孩子,或者某个节点的兄弟,只需查找对应的单链表即可,遍历整个树只需要对头节点数组进行遍历
但是此种方式不利于找某个节点的双亲,但是在数组节点中增加一个双亲节点的位置即可
*/
type child struct {
	child int //孩子节点的下标
	next  int //下一个孩子节点的下标
}

//表头,即每个真正被存在数组中的节点,包含值,和其第一个孩子节点的指针
type Node1 struct {
	Data  interface{}
	first *child
	//parent int //双亲节点的下标
}

type tree1 struct {
	nodes  []Node1 //节点数组
	root   int     //根
	length int     //总节点数量
}

/*
3.孩子兄弟表示
每个节点存数据 第一个孩子的地址,以及右边第一个兄弟的地址
这种方式最大的好处是让一个复杂的树变成了二叉树

*/

func main() {

}
